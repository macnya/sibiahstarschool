# Mutation to insert a new grade
mutation InsertGrade(
  $studentId: String!,
  $classId: String!,
  $subjectId: String!,
  $term: String!,
  $score: String,
  $comments: String,
  $recordedById: String!
) {
  insertIntogradesCollection(
    values: [{
      studentId: $studentId,
      classId: $classId,
      subjectId: $subjectId,
      term: $term,
      score: $score,
      comments: $comments,
      recordedById: $recordedById
      # gradeId will be auto-generated by @default
    }]
  ) {
    affected_rows
    records {
      node {
        gradeId
        studentId
        score
        comments
      }
    }
  }
}

# Mutation to update an existing grade
mutation UpdateGrade(
  $gradeId: String!,
  $newScore: String, # Pass null if not updating
  $newComments: String # Pass null if not updating
) {
  updategradesCollection(
    filter: { gradeId: { eq: $gradeId } },
    # Build changes array conditionally based on what's provided
    # This part requires more advanced handling in your client code
    # to construct the 'changes' array dynamically.
    # For simplicity here, we assume score and comments are being updated.
    # In a real app, you'd build this 'changes' array based on which fields were modified.
    changes: [
      { field: "score", value: $newScore },
      { field: "comments", value: $newComments }
      # You might also want an 'updatedAt' field that gets auto-updated
    ]
  ) {
    affected_rows
    records {
      node {
        gradeId
        score
        comments
      }
    }
  }
}